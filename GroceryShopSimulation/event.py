"""Assignment 1 - Grocery Store Events (Task 2)

This file should contain all of the classes necessary to model the different
kinds of events in the simulation.
"""
# Feel free to import classes and functions from
# *your other files*, but remember not to import any external libraries.
from store import GroceryStore


class Event:
    """An event.

    Events have an ordering based on the event timestamp in non-ascending
    order. Events with older timestamps are less than those with newer
    timestamps.

    This class is abstract; subclasses must implement do().

    You may, if you wish, change the API of this class to add
    extra public methods or attributes. Make sure that anything
    you add makes sense for ALL events, and not just a particular
    event type.

    Document any such changes carefully!

    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    """

    def __init__(self, timestamp):
        """Initialize an Event with a given timestamp.

        @type self: Event
        @type timestamp: int
            A timestamp for this event.
            Precondition: must be a non-negative integer.
        @rtype: None

        >>> Event(7).timestamp
        7
        """
        self.timestamp = timestamp

    # The following six 'magic methods' are overridden to allow for easy
    # comparison of Event instances. All comparisons simply perform the
    # same comparison on the 'timestamp' attribute of the two events.
    def __eq__(self, other):
        """Return whether this Event is equal to <other>.

        Two events are equal if they have the same timestamp.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first == second
        False
        >>> second.timestamp = first.timestamp
        >>> first == second
        True
        """
        return self.timestamp == other.timestamp

    def __ne__(self, other):
        """Return True iff this Event is not equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first != second
        True
        >>> second.timestamp = first.timestamp
        >>> first != second
        False
        """
        return not self.__eq__(other)

    def __lt__(self, other):
        """Return True iff this Event is less than <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first < second
        True
        >>> second < first
        False
        """
        return self.timestamp < other.timestamp

    def __le__(self, other):
        """Return True iff this Event is less than or equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first <= first
        True
        >>> first <= second
        True
        >>> second <= first
        False
        """
        return self.timestamp <= other.timestamp

    def __gt__(self, other):
        """Return True iff this Event is greater than <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first > second
        False
        >>> second > first
        True
        """
        return not self.__le__(other)

    def __ge__(self, other):
        """Return True iff this Event is greater than or equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first >= first
        True
        >>> first >= second
        False
        >>> second >= first
        True
        """
        return not self.__lt__(other)

    def do(self, store):
        """Perform this Event.

        Call methods on <store> to update its state according to the
        meaning of the event. Note: the "business logic" of what actually
        happens inside a grocery store should be handled in the GroceryStore
        class, not in any Event classes.

        Return a list of new events spawned by this event (making sure the
        timestamps are correct).

        @type self: Event
        @type store: GroceryStore
        @rtype: list[Event] || NoneType
            Return a list of events generated by performing this event if
            they exist.
            Return None if no spawned events.
        """
        raise NotImplementedError


class JoinLine(Event):
    """An join line event.

    It happens when a new customer arrive the store, or when the line
    a customer joined is closed, the customer need to join a new line.
    """
    # === Public Attributes ===
    # @type timestamp: int
    #    A timestamp for this event.
    # @type name: str
    #    The name of the customer.
    # @type items: int
    #    The number of items the customer has.

    def __init__(self, timestamp, name, num_items):
        """Initialize Join Line event with given timestamp, customer name
        and number of items.

        @type self: Join_Line
        @type timestamp: int
        @type name: str
        @type num_items: int
        @rtype: None
        """
        super(JoinLine, self).__init__(timestamp)
        self.name = name
        self.items = num_items

    def do(self, store):
        """Process the event Join Line.

        Customers will join the line that has fewest people.
        If the line a customer joins is empty, then the customer immediately
        start to check out.

        @type self: Join_Line
        @type store: GroceryStore
        @rtype: list[Event]
            A list of events generated by performing this event.
        """
        events = []
        chosen = store.join_line(self.name, self.items)
        if store.line_is_empty(chosen):
            event = BeginCheckOut(self.timestamp, self.name, self.items, chosen)
            events.append(event)
        return events


class BeginCheckOut(Event):
    """An begin checkout event.

    It happens when the line that a customer joined is empty, or when
    the previous customer finished checkout.
    """
    # === Public Attributes ===
    # @type timestamp: int
    #     A timestamp for this event.
    #
    # @type name: str
    #     The name of the customer.
    #
    # @type items: int
    #     The number of items the customer has.
    #
    # @type line_index: int
    #     The index of the line that this event is happening.

    def __init__(self, timestamp, name, items, line_index):
        """Initialize Begin Check Out with given timestamp, customer name,
        number of items,and index of the line that the customer joins

        @type timestamp: int
        @type name: str
        @type items: int
        @type line_index: int
        @rtype: None
        """
        super(BeginCheckOut, self).__init__(timestamp)
        self.name = name
        self.items = items
        self.line_index = line_index

    def do(self, store):
        """Process the event Begin Check Out.

        Customers will start check out and calculate the time they need during
        checkout. Then the customer will finish checkout.

        @type self: Begin_Check_Out
        @type store: GroceryStore
        @rtype: list[Event]
            A list of events generated by performing this event.
        """
        events = []
        time = store.spend_time(self.name, self.items)
        new_stamp = self.timestamp + time
        event = FinishCheckOut(new_stamp, self.name, self.line_index)
        events.append(event)
        return events


class FinishCheckOut(Event):
    """An finish checkout event.

    It happens after customers checkout.
    """
    # === Public Attributes ===
    # @type timestamp: int
    #     A timestamp for this event.
    #
    # @type name: str
    #     The name of the customer.
    #
    # @type line: int
    #     The index of the line that this event is happening.

    def __init__(self, timestamp, name, line):
        """Initialize Finish Check Out with given timestamp, customer name,
        and index of the line that the customer joins.

        @type timestamp: int
        @type name: str
        @type line: int
        @rtype: None
        """
        super(FinishCheckOut, self).__init__(timestamp)
        self.name = name
        self.line = line

    def do(self, store):
        """Process the event Finish Check Out.

        Customers finish check out and leave the line. The next customer will
        begin to check out if there are any.

        @type self: Finish_Check_Out
        @type store: GroceryStore
        @rtype: list[Event] || NoneType
            Return list of spawned event if there are still customers
            in the line.
            Return None if there are no more customers in this line.
        """
        events = []
        if store.find_next_customer(self.name):
            next_id = store.find_next_customer_name(self.name)
            next_num = store.find_next_customer_items(self.name)
            event = BeginCheckOut(self.timestamp, next_id, next_num, self.line)
            events.append(event)
            store.leave_store(self.line)
            return events
        else:
            store.leave_store(self.line)
            return None


class CloseLine(Event):
    """An close line event.

    It happens when a line is closed.
    """
    # === Public Attributes ===
    # @type timestamp: int
    #     A timestamp for this event.
    #
    # @type line_index: int
    #     The index of the line that should be closed.

    def __init__(self, timestamp, line_index):
        """Initialize Close Line with given timestamp, and given index of line.

        @type timestamp: int
        @type line_index: int
        @rtype: None
        """
        super(CloseLine, self).__init__(timestamp)
        self.line_index = line_index

    def do(self, store):
        """Process the event Close Line.

        Customers will leave the line from the end of the customer list.
        Then they will join a new line that is open.
        The first customer in the line will continue checkout and
        will not leave the line even when the line is closed.

        @type self: Close_Line
        @type store: GroceryStore
        @rtype: list[Event]
            A list of events generated by performing this event.
        """
        events = []
        store.close_line(self.line_index)
        close_list = store.get_customer_list(self.line_index)
        interval = 0
        for i in range(len(close_list) - 1, 0, -1):
            new_stamp = self.timestamp + interval
            event = JoinLine(new_stamp, close_list[i].name, close_list[i].items)
            events.append(event)
            store.leave_line(close_list[i].name)
            interval += 1
        return events


def create_event_list(filename):
    """Return a list of Events based on raw list of events in <filename>.

    Precondition: the file stored at <filename> is in the format specified
    by the assignment handout.

    @param filename: str
        The name of a file that contains the list of events.
    @rtype: list[Event]
    """
    events = []
    with open(filename, 'r') as file:
        for line in file:
            # Create a list of words in the line, e.g.
            # ['60', 'Arrive', 'Bob', '5'].
            tokens = line.split()
            timestamp = int(tokens[0])
            last = int(tokens[len(tokens) - 1])
            if tokens[1] == 'Arrive':
                event_element = JoinLine(timestamp, tokens[2], last)
            else:
                event_element = CloseLine(timestamp, last)
            events.append(event_element)
    return events


if __name__ == '__main__':
    import doctest

    doctest.testmod()
